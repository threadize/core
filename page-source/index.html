<!DOCTYPE html>
<html lang="en">
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1"/>
		<meta charset="utf-8"/>
		<title><%= htmlWebpackPlugin.options.title %></title>
		<meta name="description" content="Run code within workers."/>
		<link rel="shortcut icon" href="./favicon.ico">
		<script src="./three.min.js"></script>
	</head>
	<body>
		<div class="logo">
			<header>
				<h1>Threadizer</h1>
			</header>
			<pre class="full javascript">
				import Threadizer from "@threadizer/core";

				const canvas = document.createElement("canvas");

				const supports = canvas.transferControlToOffscreen instanceof Function;

				container.appendChild(canvas);

				// Convert canvas into offscreen canvas if supported.
				const offscreenCanvas = supports ? canvas.transferControlToOffscreen() : canvas;

				// Call a thread if "supports" is true, run on main-thread if not (see 3rd parameter) at the end.
				const thread = await new Threadizer(( thread )=>{

					const duration = 1000;
					const delay = 1000;
					const rotation = 0.1;
					const translation = 0.05;

					let renderer, camera, group, scene, top, middle, moving, bottom, width, height, animationStart, animationPositionStart, animationPositionEnd, movePositionTarget, moveRotationTarget;

					// Listen to the "setup" event from main thread
					thread.on("setup", ({ detail })=>{

						const { offscreenCanvas, baseURL } = detail;

						// Import ThreeJS WebGL library if inside a worker
						if( thread.isWorker ){

							importScripts(baseURL + "three.min.js");

						}

						animationPositionStart = new THREE.Vector3();
						animationPositionEnd = new THREE.Vector3();
						movePositionTarget = new THREE.Vector3();
						moveRotationTarget = new THREE.Vector3();

						function generatePlane( colors ){

							const width = 0.25;
							const height = 0.5;
							const skew = 0.25;

							const vertices = new Float32Array([
								+width + skew, +height, 0,
								-width + skew, +height, 0,
								-width - skew, -height, 0,
								+width - skew, -height, 0
							]);

							const geometry = new THREE.BufferGeometry();

							geometry.setIndex([0, 1, 2, 3, 0, 2]);
							geometry.setAttribute("position", new THREE.BufferAttribute(vertices, 3));

							geometry.setAttribute("color", new THREE.BufferAttribute(new Float32Array(geometry.attributes.position.count * 3), 3));

							for( let index = 0; index < colors.length; index++ ){

								geometry.attributes.color.setXYZ(index, colors[index].r, colors[index].g, colors[index].b);

							}

							const material = new THREE.MeshBasicMaterial({
								vertexColors: true,
								transparent: true,
								depthTest: false
							});

							material.blending = THREE.AdditiveBlending;

							const mesh = new THREE.Mesh(geometry, material);

							return mesh;

						}

						renderer = new THREE.WebGLRenderer({
							canvas: offscreenCanvas,
							alpha: true,
							antialias: true
						});

						renderer.setClearColor(0, 0);

						camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 1, 10);
						camera.position.set(0, 0, 5);

						scene = new THREE.Scene();

						group = new THREE.Object3D();
						scene.add(group);

						top = generatePlane([
							new THREE.Color(0xFB7FAC),
							new THREE.Color(0xFA929E),
							new THREE.Color(0xF4C175),
							new THREE.Color(0xF2D461)
						]);

						bottom = generatePlane([
							new THREE.Color(0x0BD6FB),
							new THREE.Color(0x4DC9F8),
							new THREE.Color(0x90A7EF),
							new THREE.Color(0xA799EB)
						]);

						middle = generatePlane([
							new THREE.Color(0x90A7EF),
							new THREE.Color(0xA799EB),
							new THREE.Color(0xFB7FAC),
							new THREE.Color(0xFA929E)
						]);

						moving = generatePlane([
							new THREE.Color(0x90A7EF),
							new THREE.Color(0xA799EB),
							new THREE.Color(0xFB7FAC),
							new THREE.Color(0xFA929E)
						]); 

						group.add(top);
						group.add(middle);
						group.add(moving);
						group.add(bottom);

						setInterval(()=>{

							const random = Math.random() > 0.5;

							animationPositionStart.copy(random ? top.position.clone() : bottom.position.clone());
							animationPositionEnd.copy(random ? bottom.position.clone() : top.position.clone());

							moving.position.copy(animationPositionStart);

							animationStart = performance.now();

						}, 5000);

						function update(){

							requestAnimationFrame(update);

							const now = performance.now();

							if( now >= delay ){

								const progress = Math.min(1, (now - delay) / duration);

								const easeProgress = progress * (2 - progress);

								top.position.set(easeProgress * -0.05, easeProgress * 0.3, 0.2);
								bottom.position.set(easeProgress * 0.05, easeProgress * -0.3, -0.2);

								const animationProgress = Math.min(1, (now - animationStart) / duration);
								const animationEaseProgress = animationProgress < 0.5 ? (2 * animationProgress * animationProgress) : (-1 + (4 - 2 * animationProgress) * animationProgress);

								const animationDelta = animationPositionEnd.clone().sub(animationPositionStart).multiplyScalar(animationEaseProgress);

								moving.position.copy(animationPositionStart).add(animationDelta);

								moving.material.opacity = 1 - Math.abs(animationProgress * 2 - 1);

							}

							const postionDelta = movePositionTarget.clone().sub(group.position).divideScalar(6);

							group.position.add(postionDelta);

							const rotationDelta = moveRotationTarget.clone().sub(group.rotation.toVector3()).divideScalar(6);

							group.rotation.setFromVector3(rotationDelta);

							renderer.render(scene, camera);

						}

						requestAnimationFrame(update);

					});

					// Listen to the "move" event from main thread
					thread.on("move", ({ detail: move })=>{

						const x = -((move.clientX / width) * 2 - 1);
						const y = -((move.clientY / height) * 2 - 1);

						movePositionTarget.set(x * translation, -y * translation, 0);
						moveRotationTarget.set(y * rotation, x * rotation, 0);

					});

					// Listen to the "setSize" event from main thread
					thread.on("setSize", ({ detail: size })=>{

						width = size.width;
						height = size.height;

						renderer.setSize(size.width, size.height, false);
						renderer.setPixelRatio(size.pixelRatio);

						const frustum = 3;
						const aspect = size.width / size.height;

						camera.left = frustum * aspect / - 2;
						camera.right = frustum * aspect / 2;
						camera.top = frustum / 2;
						camera.bottom = frustum / - 2;

						camera.updateProjectionMatrix();

					});

				}, null, !supports);

				// Transfer offscreencanvas to worker thread through a "setup" event
				thread.transfer("setup", { offscreenCanvas, baseURL: window.location.href }, [offscreenCanvas]);

				// Transfer resize event to worker thread through a "setSize" event
				window.addEventListener("resize", ()=>{

					const { width, height } = container.getBoundingClientRect();

					thread.transfer("setSize", { width, height });

				});

				// Transfer mousemove event to worker thread through "move" event
				window.addEventListener("mousemove", ({ clientX, clientY })=>{

					thread.transfer("move", { clientX, clientY });

				});

				// Trigger resize event once on page ready to trigger transfer to set initial canvas size
				window.dispatchEvent(new Event("resize"));
			</pre>
			<a class="toggle-code"></a>
		</div>
		<main>
			<section>
				<h2>Install</h2>
				<div class="content">
					<p>The package is published on <a href="https://www.npmjs.com/package/@threadizer/core" target="_blank" rel="noopener">npm</a>, sources and documentation are available on <a href="https://github.com/threadizer/core" target="_blank" rel="noopener">github</a>.</p>
					<pre class="bash">npm install @threadizer/core</pre>
				</div>
			</section>
			<section>
				<h2>Quick Start</h2>
				<div class="content">
					<p>In this example, the function is ran within the worker thread then the main thread send it a message named "custom-event" containing some data. You can send any <span class="hljs-inline">Object</span> (it must works with <span class="hljs-inline">JSON.stringify(...)</span>) or any instance of <span class="hljs-inline">ArrayBuffer</span>, <span class="hljs-inline">MessagePort</span>, <span class="hljs-inline">ImageBitmap</span> or <span class="hljs-inline">OffscreenCanvas</span>.</p>
					<pre class="full javascript" data-script="quick-start">
						import Threadizer from "@threadizer/core";

						const thread = await new Threadizer(()=>{

							self.on("custom-event", ( event )=>{

								console.log(self, event.detail);

							});

						});

						const buffer = new ArrayBuffer(1000);

						thread.transfer("custom-event", buffer, [buffer]);
					</pre>
					<a class="run-code console"></a>
				</div>
			</section>
			<section>
				<h2>Importing external libraries</h2>
				<div class="content">
					<p>You may need libraries within your worker, for that the easiest way is to compile and export your worker script into a dedicated file. To use the worker file simply place the path as first parameter:</p>
					<div class="tabs">
						<ul>
							<li data-tab="main">main.js</li>
							<li data-tab="worker">worker.js</li>
						</ul>
						<pre class="current full javascript" data-file="main" data-script="compiled-workers">
							import Threadizer from "@threadizer/core";

							const thread = await new Threadizer("path/to/worker.js");
						</pre>
						<a class="run-code console"></a>
						<pre class="full javascript" data-file="worker">
							import * as THREE from "three";

							console.log(THREE);
						</pre>
					</div>
					<p>You also can use <span class="hljs-inline">importScripts(...)</span> inside the worker to load externals or vendors scripts:</p>
					<div>
						<pre class="full javascript" data-script="compiled-workers">
							import Threadizer from "@threadizer/core";

							const thread = await new Threadizer(()=>{

								importScripts("path/to/three.min.js");

								console.log(THREE);

							});
						</pre>
						<a class="run-code console"></a>
					</div>
				</div>
			</section>
			<section>
				<h2>Deep workers</h2>
				<div class="content">
					<p>A worker can itself create sub-workers offering infinite possibility of optimisations.</p>
					<p class="warning">If a thread is destroyed, all its child threads are destroyed too. Also, remember that if a parent thread is frozen by a long process, communications among its child threads would be delayed.</p>
					<div class="tabs">
						<ul>
							<li data-tab="main">main.js</li>
							<li data-tab="worker">worker.js</li>
						</ul>
						<pre class="full javascript" data-file="main" data-script="subworkers">
							import Threadizer from "@threadizer/core";

							const thread = await new Threadizer("path/to/worker.js");
						</pre>
						<a class="run-code console"></a>
						<pre class="current full javascript" data-file="worker">
							const Threadizer = self.Threadizer.default;

							const subthreadA = await new Threadizer(()=>{

								console.log("subthread A ready");

							});

							const subthreadB = await new Threadizer(()=>{

								console.log("subthread B ready");

							});
						</pre>
					</div>
				</div>
			</section>
			<section>
				<h2>Performance</h2>
				<div class="content">
					<p>Running scripts within workers is the best way to avoid freezing the main-thread. Here is an example of a high CPU usage stress-test script, it will launch a loop of <span class="hljs-inline">1e4</span> iterations to sort an array.</p>
					<p class="warning">Running the main-thread test will cause the browser to freeze the current tab while processing (around 6 seconds with on an Intel i9, less than 20 seconds on a recent iPhone). You can check how much time the main-thread got freezed in the devtools console.</p>
					<div class="tabs">
						<ul>
							<li data-tab="worker">in worker</li>
							<li data-tab="main-thread">on main-thread</li>
						</ul>
						<div data-file="worker">
							<pre class="current full javascript" data-script="performance-worker">
								import Threadizer from "@threadizer/core";

								const thread = await new Threadizer(()=>{

									console.log("begin performance-worker");
									console.time("performance-worker");

									const array = new Array();

									for( let index = 0; index < 1e4; index++ ){

										array[index] = Math.random();

										array.sort();

									}

									console.timeEnd("performance-worker");

								});
							</pre>
							<a class="run-code console"></a>
						</div>
						<div data-file="main-thread">
							<pre class="full javascript" data-script="performance-main-thread">
								console.time("performance-worker");

								const array = new Array();

								for( let index = 0; index < 1e4; index++ ){

									array[index] = Math.random();

									array.sort();

								}

								console.timeEnd("performance-worker");
							</pre>
							<a class="run-code"></a>
						</div>
					</div>
				</div>
			</section>
		</main>
		<footer>
			<img src="./logo.png" alt="Threadizer logo representing a colorfull lightning."/>
			<p>Copyright (c) 2021 Threadizer — <a href="https://github.com/threadizer/core/blob/main/LICENSE" target="_blank" rel="noopener">Licensed</a></p>
		</footer>
	</body>
</html>